# 正则表达式 {#concept_1597614 .concept}

本文档主要介绍正则表达式的匹配方式以及特殊字符的转义处理。

## 完全匹配 {#section_3nv_fd4_5vy .section}

正则表达式的值与字符串完全一致，则是完全匹配。例如`1234`完全匹配`\d+`，但是`abc123`与`\d+`则不是完全匹配。

有些函数是部分匹配，您可以在开头与结尾添加`^`与`$`将部分匹配的场景变成完全匹配。例如正则表达式`^正则$`。更多正则表达式语法请参见[正则表达式操作](https://docs.python.org/zh-cn/3.7/library/re.html)。

不同函数的匹配模式如表格所示。

|分类|函数|匹配模式|
|--|--|----|
|全局操作函数|[e\_regex](../../../../cn.zh-CN/数据加工/数据加工语法/全局操作函数/字段值提取函数.md#section_1rn_crw_ur9)|部分匹配|
|[e\_keep\_fields](../../../../cn.zh-CN/数据加工/数据加工语法/全局操作函数/字段操作函数.md#section_e3g_856_vs6)|完全匹配|
|[e\_drop\_fields](../../../../cn.zh-CN/数据加工/数据加工语法/全局操作函数/字段操作函数.md#section_q8m_zn8_uvj)|完全匹配|
|[e\_rename](../../../../cn.zh-CN/数据加工/数据加工语法/全局操作函数/字段操作函数.md#section_dg9_67q_cjh)|完全匹配|
|[e\_kv](../../../../cn.zh-CN/数据加工/数据加工语法/全局操作函数/字段值提取函数.md#section_n3z_qjb_xpp)|部分匹配|
|[e\_search\_dict\_map](../../../../cn.zh-CN/数据加工/数据加工语法/全局操作函数/映射富化函数.md#section_pbk_lwq_04u)|部分匹配|
|[e\_search\_table\_map](../../../../cn.zh-CN/数据加工/数据加工语法/全局操作函数/映射富化函数.md#section_mp3_goc_rxa)|部分匹配|
|表达式函数|[e\_match](../../../../cn.zh-CN/数据加工/数据加工语法/表达式函数/事件检查函数.md#section_8ng_n08_z4i)|参数控制，默认为完全匹配。|
|[e\_search](../../../../cn.zh-CN/数据加工/数据加工语法/表达式函数/事件检查函数.md#section_syl_ku4_k84)|部分匹配|
|[regex\_select](../../../../cn.zh-CN/数据加工/数据加工语法/表达式函数/正则表达式函数.md#section_wis_oxa_0zf)|部分匹配|
|[regex\_findall](../../../../cn.zh-CN/数据加工/数据加工语法/表达式函数/正则表达式函数.md#section_vmz_0lw_bto)|部分匹配|
|[regex\_match](../../../../cn.zh-CN/数据加工/数据加工语法/表达式函数/正则表达式函数.md#section_p5o_wsv_w8a)|参数控制，默认为部分匹配。|
|[regex\_replace](../../../../cn.zh-CN/数据加工/数据加工语法/表达式函数/正则表达式函数.md#section_itd_2qz_jc2)|部分匹配|
|[regex\_split](../../../../cn.zh-CN/数据加工/数据加工语法/表达式函数/正则表达式函数.md#section_1pq_q2t_1i5)|部分匹配|

匹配模式示例。

-   `reg_match("abc123", r"\d+")`：匹配。默认为部分匹配模式。
-   `reg_match("abc123", r"\d+", full=True)`：不匹配。设置了完全匹配模式。
-   `reg_match("abc123", r"^\d+$")`：不匹配 。等效完全匹配模式。
-   `e_search(r'status~="\d+"')`：根据`status`字段的值匹配。与部分匹配模式等效。
-   `e_search(r'status~="^\d+$"')`：根据`status`字段的值匹配。与完全匹配模式等效。

## 字符转义 {#section_pe3_4w2_e1o .section}

正则表达式中可能会包含特殊字符，如果需要获取这些字符本身的含义，就需要进行转义。

-   通过`\`进行转义，请参见[字符转义](cn.zh-CN/.md#section_swy_abu_0i4)。
-   通过`str_regex_escape`函数进行转义。

    例如`e_drop_fields(str_regex_escape("abc.test")`，表示丢弃字段`abc.test`。而`e_drop_fields("abc.test")`则表示丢弃符合`abc?test`的字段，`?`表示任意字符。


## 分组 {#section_r6z_2z2_97g .section}

分组就是将需要重复的表达式用小括号`()`括起来，然后对这个表达式进行重复引用。以下示例为分组和不分区的区别：

``` {#codeblock_mr3_rar_tdt}
"""
处理前日志为：
SourceIP: 1.1.1.1
处理后日志为：
SourceIP: 1.1.1.1
ip: 1.1.1.1
"""
# 不分组:
e_regex("SourceIP",r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}","ip")
# 分组:
e_regex("SourceIP", "\d{1,3}(.\d{1,3}){3}", "ip")
```

## 捕获组 {#section_9ea_ls1_d0n .section}

捕获组会将捕获到的文本内容缓存在内存中，可以通过反向引用在其他表达式中使用。形式上捕获组的小括号中不是以`?:`开头。

默认情况下，每个捕获组会自动拥有一个编号。从左向右，以分组的左括号为标志，第一个出现的分组的编号为1，第二个为2，以此类推。例如：

``` {#codeblock_cg5_q0c_drw}
(\d{4})-(\d{2}-(\d{2}))

1     1 2      3     32
```

如果正则表达式中同时存在普通分组和命名分组，那么分组的编号规则是先对普通捕获组进行编号，再对命名捕获组进行编号。

支持在表达式或程序中直接引用自定义的捕获组组名。

## 非捕获组 {#section_5n0_k98_uys .section}

非捕获组不会将匹配到的文本内容缓存到内存中，形式上非捕获组的小括号中以`?:`开头。

例如我们要查找`program`和`project`，正则表达式可以表示为`pro(gram|ject)`，如果我们不希望将表达式匹配的内容缓存到内存中，此时我们可以用`pro(?:gram|ject)`进行非捕获匹配，这样既可以简洁匹配又可以节省内存。

**说明：** `(?:x)`表示匹配`x`但是不缓存匹配项，可以定义与正则表达式运算符一起使用的子表达式。

